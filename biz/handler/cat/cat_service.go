// Code generated by hertz generator.

package cat

import (
	"context"
	"strconv"

	"github.com/Gorsonpy/catCafe/biz/dal/mysql"
	cat "github.com/Gorsonpy/catCafe/biz/model/cat"
	"github.com/Gorsonpy/catCafe/biz/pack"
	"github.com/Gorsonpy/catCafe/biz/service"
	"github.com/Gorsonpy/catCafe/pkg/errno"
	"github.com/Gorsonpy/catCafe/pkg/utils"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
)

// UpdateCat .
// @router /cat [PUT]
func UpdateCat(ctx context.Context, c *app.RequestContext) {
	var err error
	var req cat.CatModel
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(cat.BaseResponse)

	c.JSON(consts.StatusOK, resp)
}

// QueryCats .
// @router /cat [GET]
func QueryCats(ctx context.Context, c *app.RequestContext) {
	var err error
	var req cat.QueryCatsReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(cat.QueryCatsResp)

	c.JSON(consts.StatusOK, resp)
}

// AddCat .
// @router /cat [POST]
func AddCat(ctx context.Context, c *app.RequestContext) {
	var err error
	var req cat.CatModel
	err = c.BindAndValidate(&req)
	resp := new(cat.AddCatResp)

	token_byte := c.GetHeader("token")
	claim, _ := utils.CheckToken(string(token_byte))
	if !mysql.IsAdmin(claim.UserId) {
		pack.PackAddCatResp(resp, errno.AuthorizationFailedErrCode, errno.PermissionFailedMsg, -1)
		c.JSON(consts.StatusOK, resp)
		return
	}

	if err != nil {
		pack.PackAddCatResp(resp, errno.ParamErrorCode, err.Error(), -1)
		c.JSON(consts.StatusOK, resp)
		return
	}

	code, msg, catId := service.AddCat(&req)
	pack.PackAddCatResp(resp, code, msg, catId)
	c.JSON(consts.StatusOK, resp)
}

// DelCat .
// @router /cat [DELETE]
func DelCat(ctx context.Context, c *app.RequestContext) {
	var err error
	var req cat.BaseRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(cat.BaseResponse)

	c.JSON(consts.StatusOK, resp)
}

// QueryCatsByPop .
// @router /cat/limit [GET]
func QueryCatsByPop(ctx context.Context, c *app.RequestContext) {
	resp := new(cat.QueryCatsResp)
	limit, err := strconv.Atoi(c.Query("limit"))
	if err != nil {
		pack.PackQueryCatsResp(resp, errno.AuthorizationFailedErrCode, errno.UnLoginFailedMsg, nil)
		c.JSON(consts.StatusOK, resp)
		return
	}

	code, msg, cats := service.QueryTopCats(int64(limit))
	pack.PackQueryCatsResp(resp, code, msg, cats)
	c.JSON(consts.StatusOK, resp)
}
